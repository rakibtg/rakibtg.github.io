{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["rx","localStorage","rxjs","p","Peer","initiator","window","location","hash","trickle","on","err","console","log","App","state","outgoing","incoming","showChat","beingWritten","chats","keys","isRx","chatBody","React","createRef","_this2","this","data","setState","JSON","stringify","send","msg","owner","parse","TextDecoder","decode","type","appendMsg","event","_this3","name","target","Object","defineProperty","value","handleKeyboardType","preventDefault","signal","react_default","a","createElement","className","onSubmit","handleSubmitConnection","bind","id","rows","cols","onChange","handleChange","_this4","toConsumableArray","concat","setTimeout","current","scrollTop","scrollHeight","map","m","i","key","ref","renderMsgs","handleMsg","placeholder","renderChat","renderP2P","Component","Boolean","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.8da51348.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport './App.css';\nimport Peer from 'simple-peer'\nconst rx = localStorage.rxjs\nconst p = new Peer({\n  initiator: window.location.hash === '#1',\n  trickle: false\n})\np.on('error', err => console.log(err))\n\nclass App extends Component {\n\n  state = {\n    outgoing: '',\n    incoming: '',\n    showChat: false,\n    beingWritten: '',\n    chats: [],\n    keys: false,\n    isRx: false,\n  }\n\n  chatBody = React.createRef()\n\n  componentDidMount() {\n    p.on('signal', data => {\n      this.setState({\n        outgoing: JSON.stringify(data)\n      })\n    })\n    p.on('connect', () => {\n      p.send(JSON.stringify({\n        msg: 'You are now connected! ðŸŽ‰',\n        owner: null\n      }))\n      this.setState({\n        showChat: true\n      })\n    })\n    p.on('data', data => {\n      const msg = JSON.parse(new TextDecoder(\"utf-8\").decode(data))\n      // console.log('on data: ', msg)\n      if(msg.type) {\n        if(msg.type === 'keyboard') {\n          if(this.state.isRx === true) {\n            this.setState({\n              keys: msg.msg\n            })\n          }\n        }\n      } else {\n        this.appendMsg({\n          msg: msg.msg,\n          owner: msg.owner\n        })\n      }\n    })\n    rx && rx === 'rxjs_dev-TypeScript2.40.33-dev-build' && this.setState({ keys: 'Type should start now...', isRx: true})\n  }\n\n  handleChange(event) {\n    const name = event.target.name\n    this.setState({\n      [name]: event.target.value\n    }, () => {\n      if(name === 'beingWritten') {\n        this.handleKeyboardType(this.state.beingWritten)\n      }\n    })\n  }\n\n  handleSubmitConnection(event) {\n    event.preventDefault()\n    p.signal(JSON.parse(this.state.incoming))\n  }\n\n  renderP2P() {\n    return (\n      <div className=\"render-p2p\">\n        <h1>ðŸ”¥ Secret Chat ðŸ—£</h1>\n        <br/><br/>\n        <form onSubmit={this.handleSubmitConnection.bind(this)}>\n          <strong>Incoming:</strong><br/>\n          <textarea \n            id=\"incoming\" \n            rows=\"8\" \n            cols=\"50\"\n            name=\"incoming\"\n            value={this.state.incoming}\n            onChange={this.handleChange.bind(this)}></textarea>\n          <br/>\n          <button>Connect</button>\n        </form>\n        <br/>\n        <strong>Outgoing:</strong><br/>\n        <textarea \n          id=\"incoming\" \n          rows=\"8\" \n          cols=\"50\" \n          name=\"outgoing\"\n          value={this.state.outgoing}\n          onChange={this.handleChange.bind(this)}></textarea>\n      </div>\n    );\n  }\n\n  appendMsg(msg) {\n    // console.log(msg)\n    this.setState({\n      chats: [\n        ...this.state.chats,\n        msg\n      ]\n    }, () => {\n      setTimeout(() => {\n        this.chatBody.current.scrollTop = this.chatBody.current.scrollHeight\n      }, 2000);\n    })\n  }\n\n  handleMsg(event) {\n    event.preventDefault()\n    this.appendMsg({\n      msg: this.state.beingWritten,\n      owner: true\n    })\n    p.send(JSON.stringify({\n      msg: this.state.beingWritten,\n      owner: false\n    }))\n    this.setState({\n      beingWritten: ''\n    })\n  }\n\n  renderMsgs() {\n    return this.state.chats.map((m, i) => <div \n      key={i}\n      className={m.owner ? \"msg-bubble bubble-owner\" : \"msg-bubble bubble-recipient\"}>\n      {m.msg}\n    </div>)\n  }\n\n  renderChat() {\n    return <div className=\"chat-wrapper\">\n      <div \n        className=\"chat-body\"\n        ref={this.chatBody}>\n        {this.renderMsgs()}\n      </div>\n      <div className=\"keys\">{this.state.keys}</div>\n      <div className=\"chat-input\">\n        <form onSubmit={this.handleMsg.bind(this)}>\n          <input \n            className=\"chat-box\"\n            name=\"beingWritten\"\n            value={this.state.beingWritten}\n            onChange={this.handleChange.bind(this)}\n            placeholder=\"Hit enter to send your reply...\"/>\n        </form>\n      </div>\n    </div>\n  }\n\n  handleKeyboardType(data) {\n    if(this.state.isRx === false) {\n      p.send(JSON.stringify({\n        msg: data,\n        type: 'keyboard'\n      }))\n    }\n  }\n\n  render() {\n    if(this.state.showChat) return this.renderChat()\n    else return this.renderP2P()\n  }\n}\n\nexport default App;\n","// In production, we register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n// This link also includes instructions on opting out of this behavior.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://goo.gl/SC7cgQ'\n          );\n        });\n      } else {\n        // Is not local host. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the old content will have been purged and\n              // the fresh content will have been added to the cache.\n              // It's the perfect time to display a \"New content is\n              // available; please refresh.\" message in your web app.\n              console.log('New content is available; please refresh.');\n\n              // Execute callback\n              if (config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type').indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}